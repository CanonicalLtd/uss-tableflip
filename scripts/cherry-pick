#!/bin/bash

VERBOSITY=0
TEMP_D=""
CR=$'\n'


error() { echo "$@" 1>&2; }
fail() { [ $# -eq 0 ] || error "$@"; exit 1; }

PKG_NAME=$(dpkg-parsechangelog --show-field Source) ||
    fail "failed to read Source from changelog"
CHERRY_PICK_DATA=debian/${PKG_NAME}-cherry-picks
RECIPE_FIX_COMMIT=debian/${PKG_NAME}-cherry-pick-recipe-fix

Usage() {
    cat <<EOF
Usage: ${0##*/} [ options ] <<ARGUMENTS>>

   Cherry pick a patch into debian/patches.
   Useful to grab an upstream commit to the current packaging branch.

   options:
      -h | --help          show help
      -d | --daily-remote  the remote from which to checkout the daily branch.
                           Default: origin
      -v | --verbose       increase verbosity
EOF
}

bad_Usage() { Usage 1>&2; [ $# -eq 0 ] || error "$@"; return 1; }
cleanup() {
    [ -z "${TEMP_D}" -o ! -d "${TEMP_D}" ] || rm -Rf "${TEMP_D}"
}

debug() {
    local level=${1}; shift;
    [ "${level}" -gt "${VERBOSITY}" ] && return
    error "${@}"
}

shorten() {
    local name="$1" len="70"
    while [ "${#name}" -gt "$len" ]; do
        name="${name%-*}"
    done
    _RET="$name"
}

print_commit() {
    local subject="$1" author="$2" bugs="$3" aname=""
    aname=${author% <*}
    echo "$subject${bugs:+ (LP: ${bugs})}"
}

print_bugs() {
    local subject="$1" author="$2" bugs="$3" aname=""
    echo "$bugs"
}

git_log_to_dch() {
    # call printer with subject, author and bugs as extracted
    # from either git format-patch output or git show output.
    local line="" commit="" lcommit="" bugs=""
    local printer="${1:-print_commit}"
    while :; do
        read line || break
        case "$line" in
            commit\ *|From\ *)
                if [ -n "$commit" ]; then
                    "$printer" "$subject" "$author" "$bugs"
                fi
                commit=${line#* }
                commit=${commit%% *}
                bugs=""
                author=""
                subject=""
                ;;
            Author:\ *|From:\ *) author="${line#*: }";;
            LP:*) bugs="${bugs:+${bugs}, }${line#*: }";;
            "") [ -z "$subject" ] && read subject;;
            Subject:\ *)
                subject="${line#Subject: }"
                subject="${subject#\[PATCH\] }"
                ;;
        esac
    done
    if [ -n "$commit" ]; then
        "$printer" "$subject" "$author" "$bugs"
    fi
}

gitcmd() {
    git "$@" || fail "Failed running git $@"
}

run_quilt() {
    local diffargs="-p ab --no-timestamps --no-index"
    QUILT_PATCHES="debian/patches" \
        QUILT_DIFF_OPTS="-p" \
        QUILT_PATCH_OPTS="--reject-format=unified" \
        QUILT_DIFF_ARGS="$diffargs --color=auto" \
        QUILT_REFRESH_ARGS="$diffargs" \
        LANG=C \
        quilt --quiltrc - "$@"
}

NEW_VERSION=""

drop_cherry_pick_from_daily_branch() {
    local local_cpick_commit="$1" daily_remote="$2"
    cur_br=$(gitcmd rev-parse --abbrev-ref HEAD)
    daily_br=${cur_br/ubuntu/ubuntu\/daily}
    gitcmd fetch ${daily_remote}
    echo "Backing out cherry-pick from ${daily_br} branch"
    if [ ! -z "$(gitcmd show-ref refs/heads/${daily_br})" ]; then
        # Branch already exists so refresh it to remote/ubuntu/daily/<series>
        gitcmd checkout ${daily_br}
        gitcmd reset --hard ${daily_remote}/${daily_br}
    else
        # Create local checkout for daily branch
        gitcmd checkout ${daily_remote}/${daily_br} -b ${daily_br}
    fi
    gitcmd cherry-pick ${local_cpick_commit}
    gitcmd revert ${local_cpick_commit}
    # switch back to current development branch
    gitcmd checkout ${cur_br}
}

apply_one_cherry_pick() {
    local r="" commit_in="$1" daily_remote="$2" chash="" shash="" sname=""
    local fname="" cur_br=""
    cur_br=$(gitcmd rev-parse --abbrev-ref HEAD)
    chash=$(gitcmd show --quiet "--pretty=format:%H" "${commit_in}")

    if git merge-base --is-ancestor "$chash" HEAD; then
        error "current branch '$cur_br' already contains $commit_in ($chash)"
        return 1
    fi

    out=$(gitcmd show --abbrev=8 --quiet "--pretty=format:%h %f" "$chash")

    shash=${out% *}
    sname=${out#* }
    longname="cpick-$shash-$sname"
    shorten "$longname"
    fname="$_RET"

    [ -d debian/patches ] || mkdir -p debian/patches ||
        { error "failed to make debian/patches"; return 1; }

    local series="debian/patches/series" fpath="debian/patches/$fname"
    if [ -e "$series" ] && out=$(grep -- "-${shash}-" "$series"); then
        error "$chash already exists in $series"
        error "  $out"
        return 1
    fi

    if [ -e "$series" ]; then
        if out=$(run_quilt applied 2>&1); then
            error "there are quilt patches applied!"
            error "$out"
            return 1
        fi
    fi

    gitcmd format-patch --stdout -1 "$chash" > "$fpath"

    echo "$fname" >> "$series" ||
        { error "failed to write to $series"; return 1; }

    run_quilt push "$fname" ||
        { error "patches do not cleanly apply"; return 1; }
    run_quilt refresh && run_quilt pop -a ||
        { error "failed to refresh or pop quilt"; return 1; }

    local message=""
    message=$(git_log_to_dch < "$fpath") ||
        { error "failed getting log entry from $fpath"; return 1; }

    if [ -z "${NEW_VERSION}" ]; then
        dch -i "cherry-pick $shash: $message"
    else
        dch --newversion ${NEW_VERSION} -m "cherry-pick $shash: $message"
    fi

    dch -e || {
        r=$?;
        error "dch -e exited $r";
        return $r;
    }

    local commit_files=""
    commit_files=( "$series" "$fpath" )
    gitcmd diff HEAD "${commit_files[@]}"

    echo -n "Commit this change? (Y/n): "
    read answer || fail "failed to read answer"
    case "$answer" in
        n|[Nn][oO]) exit 1;;
    esac

    bugs=$(git_log_to_dch print_bugs < "$fpath")
    msg="cherry pick $shash${bugs:+${CR}${CR}LP: ${bugs}}"
    gitcmd add "$series" "$fpath"

    gitcmd commit -m "$msg" "${commit_files[@]}"
    local_cpickhash=$(gitcmd show --quiet "--pretty=format:%H")

    gitcmd commit -m "update changelog" debian/changelog
    drop_cherry_pick_from_daily_branch ${local_cpickhash} ${daily_remote}

    return 0
}

main() {
    local short_opts="hd:v"
    local long_opts="help,daily-remote:,verbose"
    local getopt_out=""
    getopt_out=$(getopt --name "${0##*/}" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage; return; }

    local cur="" next="" DAILY_REMOTE="origin"

    while [ $# -ne 0 ]; do
        cur="$1"; next="$2";
        case "$cur" in
            -h|--help) Usage ; exit 0;;
            -d|--daily-remote) DAILY_REMOTE=${next}; shift;;
            -v|--verbose) VERBOSITY=$((${VERBOSITY}+1));;
            --) shift; break;;
        esac
        shift;
    done

	[ -n "$TEMP_D" ] ||
        TEMP_D=$(mktemp -d "${TMPDIR:-/tmp}/${0##*/}.XXXXXX") ||
		{ error "failed to make tempdir"; return 1; }
	trap cleanup EXIT

    [ $# -gt 0 ] || { bad_Usage "must provide commit-ish"; return; }
    apply_one_cherry_pick $1 ${DAILY_REMOTE}

    return 0
}

main "$@"
# vi: ts=4 expandtab
